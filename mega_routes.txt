
/app/api/auth/route.ts
import { NextRequest, NextResponse } from 'next/server';

const PASSWORD = 'zitoo';

export async function POST(req: NextRequest) {
	try {
		const body = await req.json().catch(() => ({}));
		const pw = (body?.password || '').toString();
		if (pw !== PASSWORD) {
			return NextResponse.json({ error: 'Invalid password' }, { status: 401 });
		}
		const res = NextResponse.json({ ok: true });
		res.cookies.set('auth', '1', {
			httpOnly: true,
			secure: process.env.NODE_ENV === 'production',
			sameSite: 'lax',
			path: '/',
			maxAge: 60 * 60 * 24 * 7 // 7 days
		});
		return res;
	} catch (e: any) {
		return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });
	}
}




/app/api/contacts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = 'https://upxztevetixqwlzpnjfv.supabase.co';
const SUPABASE_SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVweHp0ZXZldGl4cXdsenBuamZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0OTI1MjQsImV4cCI6MjA3NTA2ODUyNH0.I-geY9rd_7vcqhsktT2pUeo9-tnA-087ic3W1Qtw-Sw';

function getSupabase() {
	return createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
		auth: { persistSession: false },
		global: { headers: { 'x-client-info': 'contacts-list-web' } }
	});
}

export async function GET(_req: NextRequest) {
	try {
		const supabase = getSupabase();
		const { data, error } = await supabase
			.from('jordan_contacts')
			.select('contact_id,full_name,first_name,last_name');
		if (error) {
			return NextResponse.json({ error: error.message }, { status: 500 });
		}
		const seen = new Set<string>();
		const contacts = (data || [])
			.filter((r: any) => r.contact_id && typeof r.contact_id === 'string')
			.map((r: any) => {
				const label =
					(r.full_name && String(r.full_name).trim()) ||
					([r.first_name, r.last_name].filter(Boolean).join(' ').trim()) ||
					r.contact_id;
				return { id: r.contact_id as string, label: label as string };
			})
			.filter(c => {
				if (seen.has(c.id)) return false;
				seen.add(c.id);
				return true;
			})
			.sort((a, b) => a.label.localeCompare(b.label));
		return NextResponse.json({ contacts });
	} catch (e: any) {
		return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });
	}
}




/app/api/pulled-zips/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = 'https://upxztevetixqwlzpnjfv.supabase.co';
const SUPABASE_SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVweHp0ZXZldGl4cXdsenBuamZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0OTI1MjQsImV4cCI6MjA3NTA2ODUyNH0.I-geY9rd_7vcqhsktT2pUeo9-tnA-087ic3W1Qtw-Sw';
const FIXED_LOCATION_ID = 'Ypfq5TDjEbkz5WdFRLgt';

function getSupabase() {
  return createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
    auth: { persistSession: false },
    global: { headers: { 'x-client-info': 'pulled-zips-web' } }
  });
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json().catch(() => ({}));
    const clientContactId = (body?.client_contact_id || '').toString().trim();
    const locationId = FIXED_LOCATION_ID;
    const zip = (body?.zip || '').toString().trim();
    if (!clientContactId) {
      return NextResponse.json({ error: 'Missing client_contact_id' }, { status: 400 });
    }
    if (!zip) {
      return NextResponse.json({ error: 'Missing zip' }, { status: 400 });
    }
    const supabase = getSupabase();
    const { data: existing, error: selErr } = await supabase
      .from('pulled_zips')
      .select('id')
      .eq('client_contact_id', clientContactId)
      .eq('location_id', locationId)
      .eq('zip', zip)
      .limit(1);
    if (selErr) {
      return NextResponse.json({ error: selErr.message }, { status: 500 });
    }
    if (existing && existing.length > 0) {
      return NextResponse.json({ created: 0, exists: true });
    }
    const { error: insErr } = await supabase
      .from('pulled_zips')
      .insert([{ client_contact_id: clientContactId, location_id: locationId, zip }]);
    if (insErr) {
      return NextResponse.json({ error: insErr.message }, { status: 500 });
    }
    return NextResponse.json({ created: 1, exists: false });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });
  }
}




/app/api/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { parse } from 'csv-parse/sync';

// ─────────────────────────────────────────────────────────────────────────────
// CONFIG — hard-coded Supabase details (server-only)
// ─────────────────────────────────────────────────────────────────────────────
const SUPABASE_URL = 'https://upxztevetixqwlzpnjfv.supabase.co';
const SUPABASE_SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVweHp0ZXZldGl4cXdsenBuamZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0OTI1MjQsImV4cCI6MjA3NTA2ODUyNH0.I-geY9rd_7vcqhsktT2pUeo9-tnA-087ic3W1Qtw-Sw';
const TABLE_NAME = 'contact_queue';
const OLD_TAG_3_VALUE = 'modern';
const INSERT_BATCH_SIZE = 1000;

// ─────────────────────────────────────────────────────────────────────────────
// Supabase client (server-side)
// ─────────────────────────────────────────────────────────────────────────────
function getSupabase() {
	return createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
		auth: { persistSession: false },
		global: { headers: { 'x-client-info': 'pull-lists-csv-web' } }
	});
}

// ─────────────────────────────────────────────────────────────────────────────
// Helpers (aligned with provided Node script)
// ─────────────────────────────────────────────────────────────────────────────
function isValidZip(zip: unknown): boolean {
	return /^\d{5}(-\d{4})?$/.test((zip || '') as string);
}

function normalizeAddress(addr: unknown): string {
	return (addr ? String(addr) : '').trim().toLowerCase();
}

function normalizeFirstName(name: unknown): string {
	const s = (name ? String(name) : '').trim();
	return s ? s[0].toUpperCase() + s.slice(1).toLowerCase() : '';
}

function toE164US(phone: unknown): string | undefined {
	if (!phone) return undefined;
	const raw = String(phone);
	const digits = raw.replace(/\D+/g, '');
	if (digits.length === 11 && digits.startsWith('1')) return `+${digits}`;
	if (digits.length === 10) return `+1${digits}`;
	if (raw.startsWith('+')) return raw;
	return undefined;
}

function chooseWireless(row: Record<string, unknown>): string | null {
	for (let i = 1; i <= 10; i++) {
		const p = row[`phone${i}`]?.toString().trim();
		const t = row[`phone${i}_type`]?.toString().trim().toUpperCase();
		if (t === 'W' && p) return p;
	}
	return null;
}

function parsePropertyAddress(addrRaw: unknown): {
	street?: string;
	city?: string;
	state?: string;
	zip?: string;
} {
	const out: { street?: string; city?: string; state?: string; zip?: string } = {};
	if (!addrRaw) return out;
	const s = String(addrRaw).trim();
	const parts = s.split(',').map(p => p.trim()).filter(Boolean);
	if (parts.length >= 1) out.street = parts[0];
	if (parts.length >= 2) out.city = parts[1];
	const tail = parts.length >= 3 ? parts[2] : parts.length >= 2 ? parts[1] : '';
	let m = /([A-Za-z]{2})\s+(\d{5}(?:-\d{4})?)/.exec(tail);
	if (m) {
		out.state = m[1].toUpperCase();
		out.zip = m[2];
	}
	if (!out.state || !out.zip) {
		m = /([A-Za-z]{2})\s+(\d{5}(?:-\d{4})?)$/.exec(s);
		if (m) {
			out.state = out.state || m[1].toUpperCase();
			out.zip = out.zip || m[2];
		}
	}
	return out;
}

function cleanRows(rawRows: Record<string, unknown>[]) {
	const kept: Record<string, unknown>[] = [];
	const seenAddr = new Set<string>();
	for (const row of rawRows) {
		const wireless = chooseWireless(row);
		if (!wireless) continue;
		const addrNorm = normalizeAddress(row.propertyAddress);
		if (addrNorm && seenAddr.has(addrNorm)) continue;
		const cleaned = { ...row };
		(cleaned as any).firstName = normalizeFirstName(row.firstName);
		(cleaned as any).wireless_choice = wireless;
		if (addrNorm) seenAddr.add(addrNorm);
		kept.push(cleaned);
	}
	return kept;
}

function toQueueRow(
	cleaned: Record<string, any>,
	clientContactId: string,
	locationId: string
) {
	const firstName: string = cleaned.firstName ?? '';
	const lastName: string = cleaned.lastName ?? '';
	const fullName = `${firstName || ''} ${lastName || ''}`.trim() || null;
	const addressFull = cleaned.propertyAddress || null;
	const parsed = parsePropertyAddress(addressFull);
	const postalCode = parsed.zip && isValidZip(parsed.zip) ? parsed.zip : null;
	const e164 = toE164US(cleaned.wireless_choice);

	const email1 = cleaned.email1 ?? null;
	const email2 = cleaned.email2 ?? null;
	const email3 = cleaned.email3 ?? null;
	const phone1 = cleaned.phone1 ?? null;
	const phone1_type = cleaned.phone1_type ?? null;
	const phone2 = cleaned.phone2 ?? null;
	const phone2_type = cleaned.phone2_type ?? null;
	const phone3 = cleaned.phone3 ?? null;
	const phone3_type = cleaned.phone3_type ?? null;

	return {
		client_contact_id: clientContactId,
		location_id: locationId,
		zip: postalCode ?? null,
		first_name: firstName || null,
		last_name: lastName || null,
		full_name: fullName,
		email1,
		email2,
		email3,
		phone1,
		phone1_type,
		phone2,
		phone2_type,
		phone3,
		phone3_type,
		wireless_choice: cleaned.wireless_choice ?? null,
		e164_phone: e164 ?? null,
		property_address: addressFull,
		address_street: parsed.street ?? null,
		address_city: parsed.city ?? null,
		address_state: parsed.state ?? null,
		address_postal_code: postalCode ?? null,
		country: 'US',
		source: 'csv pull-lists web',
		status: 'pending',
		error: null,
		old_tag_3: OLD_TAG_3_VALUE,
		raw_data: cleaned
	};
}

async function fetchExistingByZips(
	supabase: ReturnType<typeof getSupabase>,
	zips: string[]
) {
	const zipList = Array.from(new Set(zips.filter(z => isValidZip(z))));
	const CHUNK = 100;
	const existing: { address_postal_code?: string | null; e164_phone?: string | null; property_address?: string | null }[] = [];
	for (let i = 0; i < zipList.length; i += CHUNK) {
		const chunk = zipList.slice(i, i + CHUNK);
		const { data, error } = await supabase
			.from(TABLE_NAME)
			.select('address_postal_code,e164_phone,property_address')
			.in('address_postal_code', chunk);
		if (error) {
			throw new Error(`Supabase select failed: ${error.message}`);
		}
		if (data?.length) existing.push(...data);
	}
	return existing;
}

function buildExistingSets(existingRows: { address_postal_code?: string | null; e164_phone?: string | null; property_address?: string | null }[]) {
	const byZipAndE164 = new Set<string>();
	const byZipAndAddr = new Set<string>();
	for (const r of existingRows) {
		const zip = r.address_postal_code || null;
		const e = r.e164_phone || null;
		const addrNorm = normalizeAddress(r.property_address);
		if (zip && e) byZipAndE164.add(`${zip}__${e}`);
		if (zip && addrNorm) byZipAndAddr.add(`${zip}__${addrNorm}`);
	}
	return { byZipAndE164, byZipAndAddr };
}

async function upsertPulledZips(
	supabase: ReturnType<typeof getSupabase>,
	clientContactId: string,
	locationId: string,
	zips: string[]
) {
	const zipList = Array.from(new Set(zips.filter(z => isValidZip(z))));
	if (zipList.length === 0) return { created: 0 };
	// Fetch existing rows for this contact+location for these zips
	const { data: existing, error: selErr } = await supabase
		.from('pulled_zips')
		.select('zip')
		.eq('client_contact_id', clientContactId)
		.eq('location_id', locationId)
		.in('zip', zipList);
	if (selErr) {
		throw new Error(`Supabase select pulled_zips failed: ${selErr.message}`);
	}
	const existingSet = new Set<string>((existing || []).map(r => (r as any).zip).filter(Boolean));
	const missing = zipList.filter(z => !existingSet.has(z));
	if (missing.length === 0) return { created: 0 };
	const rows = missing.map(z => ({
		client_contact_id: clientContactId,
		location_id: locationId,
		zip: z
	}));
	const { error: insErr, count } = await supabase
		.from('pulled_zips')
		.insert(rows, { count: 'exact' });
	if (insErr) {
		throw new Error(`Supabase insert pulled_zips failed: ${insErr.message}`);
	}
	return { created: typeof count === 'number' ? count : rows.length };
}

function readCsvRowsFromString(rawCsv: string) {
	const records = parse(rawCsv, {
		columns: true,
		skip_empty_lines: true,
		trim: true
	}) as Record<string, unknown>[];
	return records.map(r => {
		const out: Record<string, unknown> = { ...r };
		for (let i = 1; i <= 10; i++) {
			const pKey = `phone${i}`;
			const tKey = `phone${i}_type`;
			if (!(pKey in out)) out[pKey] = '';
			if (!(tKey in out)) out[tKey] = '';
		}
		for (let i = 1; i <= 3; i++) {
			const eKey = `email${i}`;
			if (!(eKey in out)) out[eKey] = '';
		}
		if (!('firstName' in out)) out.firstName = '';
		if (!('lastName' in out)) out.lastName = '';
		if (!('propertyAddress' in out)) out.propertyAddress = '';
		return out;
	});
}

async function insertBatch(
	supabase: ReturnType<typeof getSupabase>,
	rows: any[]
) {
	if (!rows.length) return { inserted: 0, failed: 0, errors: [] as { batchStart: number; message: string }[] };
	let inserted = 0;
	const errors: { batchStart: number; message: string }[] = [];
	for (let i = 0; i < rows.length; i += INSERT_BATCH_SIZE) {
		const slice = rows.slice(i, i + INSERT_BATCH_SIZE);
		const { error, count } = await supabase.from(TABLE_NAME).insert(slice, { count: 'exact' });
		if (error) {
			errors.push({ batchStart: i, message: error.message });
		} else {
			inserted += typeof count === 'number' ? count : slice.length;
		}
	}
	return { inserted, failed: rows.length - inserted, errors };
}

// ─────────────────────────────────────────────────────────────────────────────
// POST /api/upload
// form-data: file (csv), client_contact_id, location_id
// ─────────────────────────────────────────────────────────────────────────────
export async function POST(req: NextRequest) {
	try {
		const form = await req.formData();
		const file = form.get('file') as File | null;
		const clientContactId = (form.get('client_contact_id') || '').toString().trim();
		const locationId = (form.get('location_id') || '').toString().trim();
		const pulledZipRaw = (form.get('pulled_zip') || '').toString().trim();
		if (!file) {
			return NextResponse.json({ error: 'Missing CSV file' }, { status: 400 });
		}
		if (!clientContactId || !locationId) {
			return NextResponse.json({ error: 'Both client_contact_id and location_id are required' }, { status: 400 });
		}

		// 1) Read CSV
		const buf = Buffer.from(await file.arrayBuffer());
		const csvText = buf.toString('utf8');
		const rawRows = readCsvRowsFromString(csvText);
		const totalRead = rawRows.length;

		// 2) Clean
		const cleaned = cleanRows(rawRows);

		// 3) Map to payloads
		const payloads = cleaned.map(r => toQueueRow(r as any, clientContactId, locationId));

		// 4) Collect zips for duplicate lookup (unchanged behavior)
		const zips = Array.from(new Set(payloads.map(p => p.address_postal_code).filter((z: string | null) => z && isValidZip(z)) as string[]));

		// 5) Load existing for those zips
		const supabase = getSupabase();
		const existing = zips.length ? await fetchExistingByZips(supabase, zips) : [];
		const { byZipAndE164, byZipAndAddr } = buildExistingSets(existing);

		// 6) Filter duplicates by rule
		const toInsert: any[] = [];
		let skippedAsDuplicate = 0;
		for (const row of payloads) {
			const zip = row.address_postal_code || null;
			const e = row.e164_phone || null;
			const addrNorm = normalizeAddress(row.property_address);
			const dupByPhone = zip && e && byZipAndE164.has(`${zip}__${e}`);
			const dupByAddr = zip && addrNorm && byZipAndAddr.has(`${zip}__${addrNorm}`);
			if (dupByPhone || dupByAddr) {
				skippedAsDuplicate++;
				continue;
			}
			toInsert.push(row);
		}

		// 7) Insert
		const { inserted, failed, errors } = await insertBatch(supabase, toInsert);

		// 9) Ensure pulled_zips has entry for user-provided zip (no auto-detect)
		let pulledZipsCreated = 0;
		if (pulledZipRaw) {
			const res = await upsertPulledZips(supabase, clientContactId, locationId, [pulledZipRaw]);
			pulledZipsCreated = res.created;
		}

		// 8) Summary
		return NextResponse.json({
			summary: {
				read_from_csv: totalRead,
				kept_after_clean: cleaned.length,
				duplicates_skipped_db: skippedAsDuplicate,
				attempted_to_insert: toInsert.length,
				inserted_successfully: inserted,
				failed_inserts: failed,
				pulled_zips_created: pulledZipsCreated
			},
			errors: errors.slice(0, 10)
		});
	} catch (err: any) {
		return NextResponse.json(
			{ error: err?.message || 'Unknown error' },
			{ status: 500 }
		);
	}
}




/app/layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <header className="w-full border-b border-zinc-200 bg-white py-3 dark:border-zinc-800 dark:bg-zinc-900">
          <div className="mx-auto flex max-w-5xl items-center justify-between px-4">
            <div className="text-sm font-semibold text-zinc-900 dark:text-zinc-50">Uploader</div>
            <nav className="flex gap-4 text-sm">
              <a href="/" className="text-zinc-700 hover:underline dark:text-zinc-300">Upload</a>
              <a href="/pulled-zips" className="text-zinc-700 hover:underline dark:text-zinc-300">Add to Pulled Zips</a>
            </nav>
          </div>
        </header>
        {children}
      </body>
    </html>
  );
}


/app/login/page.tsx
'use client';
import { useState } from 'react';
import { useRouter } from 'next/navigation';

export default function Login() {
	const [password, setPassword] = useState('');
	const [error, setError] = useState<string | null>(null);
	const [loading, setLoading] = useState(false);
	const router = useRouter();

	async function onSubmit(e: React.FormEvent) {
		e.preventDefault();
		setError(null);
		setLoading(true);
		try {
			const res = await fetch('/api/auth', {
				method: 'POST',
				headers: { 'content-type': 'application/json' },
				body: JSON.stringify({ password })
			});
			if (!res.ok) {
				const j = await res.json().catch(() => ({}));
				setError(j?.error || 'Invalid password');
				return;
			}
			router.replace('/');
		} catch (err: any) {
			setError(err?.message || 'Unexpected error');
		} finally {
			setLoading(false);
		}
	}

	return (
		<div className="flex min-h-screen items-center justify-center bg-zinc-50 font-sans dark:bg-black">
			<main className="flex w-full max-w-sm flex-col gap-6 rounded-lg bg-white p-6 shadow-sm dark:bg-zinc-900">
				<h1 className="text-xl font-semibold text-zinc-900 dark:text-zinc-50">Enter Password</h1>
				<form onSubmit={onSubmit} className="flex flex-col gap-4">
					<input
						type="password"
						placeholder="Password"
						value={password}
						onChange={(e) => setPassword(e.target.value)}
						className="rounded-md border border-zinc-300 bg-white px-3 py-2 text-zinc-900 outline-none focus:ring-2 focus:ring-zinc-400 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50"
					/>
					<button
						type="submit"
						disabled={loading}
						className="inline-flex items-center justify-center rounded-md bg-black px-4 py-2 text-white hover:bg-zinc-800 disabled:opacity-60 dark:bg-zinc-100 dark:text-black dark:hover:bg-white"
					>
						{loading ? 'Checking…' : 'Enter'}
					</button>
				</form>
				{error && (
					<div className="rounded-md border border-red-300 bg-red-50 p-3 text-sm text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-100">
						{error}
					</div>
				)}
			</main>
		</div>
	);
}




/app/page.tsx
'use client';
import { useState } from "react";
import { useEffect } from "react";

export default function Home() {
	const [clientContactId, setClientContactId] = useState("");
	const [file, setFile] = useState<File | null>(null);
	const [isUploading, setIsUploading] = useState(false);
	const [result, setResult] = useState<any>(null);
	const [error, setError] = useState<string | null>(null);
	const [contacts, setContacts] = useState<{ id: string; label: string }[] | null>(null);
	const [loadingContacts, setLoadingContacts] = useState(false);
	const [contactQuery, setContactQuery] = useState("");
	const [dropdownOpen, setDropdownOpen] = useState(false);
	const FIXED_LOCATION_ID = 'Ypfq5TDjEbkz5WdFRLgt';

	useEffect(() => {
		let mounted = true;
		async function load() {
			try {
				setLoadingContacts(true);
				const res = await fetch('/api/contacts', { method: 'GET' });
				const json = await res.json();
				if (!res.ok) {
					throw new Error(json?.error || 'Failed to load contacts');
				}
				if (mounted) setContacts(json.contacts || []);
			} catch (e: any) {
				if (mounted) setError(e?.message || 'Failed to load contacts');
			} finally {
				if (mounted) setLoadingContacts(false);
			}
		}
		load();
		return () => { mounted = false; };
	}, []);

	async function handleSubmit(e: React.FormEvent) {
		e.preventDefault();
		setError(null);
		setResult(null);
		if (!file) {
			setError("Please choose a CSV file.");
			return;
		}
		if (!clientContactId) {
			setError("Please select a Contact.");
			return;
		}
		try {
			setIsUploading(true);
			const formData = new FormData();
			formData.append('file', file);
			formData.append('client_contact_id', clientContactId);
			formData.append('location_id', FIXED_LOCATION_ID);
			const res = await fetch('/api/upload', {
				method: 'POST',
				body: formData
			});
			const json = await res.json();
			if (!res.ok) {
				setError(json?.error || 'Upload failed');
			} else {
				setResult(json);
			}
		} catch (err: any) {
			setError(err?.message || 'Unexpected error');
		} finally {
			setIsUploading(false);
		}
	}

	return (
		<div className="flex min-h-screen items-center justify-center bg-zinc-50 font-sans dark:bg-black">
			<main className="flex w-full max-w-3xl flex-col gap-8 rounded-lg bg-white p-8 shadow-sm dark:bg-zinc-900">
				<h1 className="text-2xl font-semibold text-zinc-900 dark:text-zinc-50">CSV Uploader</h1>
				<form onSubmit={handleSubmit} className="flex flex-col gap-4">
					<div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
						<label className="flex flex-col gap-2 relative">
							<span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">Contact</span>
							<input
								type="text"
								placeholder={loadingContacts ? 'Loading…' : 'Search contacts'}
								value={contactQuery}
								onChange={(e) => {
									setContactQuery(e.target.value);
									setDropdownOpen(true);
								}}
								onFocus={() => setDropdownOpen(true)}
								className="rounded-md border border-zinc-300 bg-white px-3 py-2 text-zinc-900 outline-none focus:ring-2 focus:ring-zinc-400 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50"
							/>
							{/* Upward-opening dropdown */}
							{dropdownOpen && (
								<div
									className="absolute bottom-full left-0 right-0 mb-2 max-h-60 overflow-auto rounded-md border border-zinc-300 bg-white shadow-lg dark:border-zinc-700 dark:bg-zinc-800 z-10"
									onMouseLeave={() => setDropdownOpen(false)}
								>
									{(contacts || [])
										.filter(c => c.label.toLowerCase().includes(contactQuery.toLowerCase()))
										.slice(0, 200)
										.map(c => (
											<button
												type="button"
												key={c.id}
												onClick={() => {
													setClientContactId(c.id);
													setContactQuery(c.label);
													setDropdownOpen(false);
												}}
												className={`block w-full cursor-pointer px-3 py-2 text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 ${clientContactId === c.id ? 'bg-zinc-100 dark:bg-zinc-700' : ''}`}
											>
												{c.label}
											</button>
										))}
									{(contacts && (contacts.filter(c => c.label.toLowerCase().includes(contactQuery.toLowerCase())).length === 0)) && (
										<div className="px-3 py-2 text-sm text-zinc-500 dark:text-zinc-300">No results</div>
									)}
								</div>
							)}
							{clientContactId && (
								<div className="text-xs text-zinc-500 dark:text-zinc-400">Selected ID: {clientContactId}</div>
							)}
						</label>
						<div className="flex flex-col gap-2">
							<span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">Location</span>
							<div className="rounded-md border border-zinc-300 bg-zinc-50 px-3 py-2 text-zinc-900 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50">
								Jayden
							</div>
						</div>
					</div>
					<label className="flex flex-col gap-2">
						<span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">CSV File</span>
						<input
							type="file"
							accept=".csv,text/csv"
							onChange={(e) => setFile(e.target.files?.[0] || null)}
							className="rounded-md border border-zinc-300 bg-white px-3 py-2 text-zinc-900 file:mr-4 file:rounded-md file:border-0 file:bg-zinc-200 file:px-4 file:py-2 file:text-sm dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50 dark:file:bg-zinc-700"
						/>
					</label>
					<button
						type="submit"
						disabled={isUploading}
						className="inline-flex items-center justify-center rounded-md bg-black px-4 py-2 text-white hover:bg-zinc-800 disabled:opacity-60 dark:bg-zinc-100 dark:text-black dark:hover:bg-white"
					>
						{isUploading ? 'Uploading…' : 'Upload'}
					</button>
				</form>
				{error && (
					<div className="rounded-md border border-red-300 bg-red-50 p-4 text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-100">
						{error}
					</div>
				)}
				{result?.summary && (
					<div className="rounded-md border border-zinc-200 bg-zinc-50 p-4 text-sm text-zinc-800 dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100">
						<h2 className="mb-2 text-base font-semibold">Summary</h2>
						<ul className="grid grid-cols-1 gap-1 sm:grid-cols-2">
							<li>Read from CSV: <strong>{result.summary.read_from_csv}</strong></li>
							<li>Kept after clean: <strong>{result.summary.kept_after_clean}</strong></li>
							<li>Duplicates skipped (DB): <strong>{result.summary.duplicates_skipped_db}</strong></li>
							<li>Attempted to insert: <strong>{result.summary.attempted_to_insert}</strong></li>
							<li>Inserted successfully: <strong>{result.summary.inserted_successfully}</strong></li>
							<li>Failed inserts: <strong>{result.summary.failed_inserts}</strong></li>
						</ul>
						{result.errors?.length ? (
							<div className="mt-3">
								<div className="mb-1 font-medium">Sample errors:</div>
								<ul className="list-disc pl-6">
									{result.errors.map((e: any, idx: number) => (
										<li key={idx} className="break-words">
											batchStart={e.batchStart} :: {e.message}
										</li>
									))}
								</ul>
							</div>
						) : null}
					</div>
				)}
			</main>
		</div>
	);
}


/app/pulled-zips/page.tsx
'use client';
import { useEffect, useState } from 'react';
import Link from 'next/link';

export default function PulledZipsPage() {
  const [contacts, setContacts] = useState<{ id: string; label: string }[] | null>(null);
  const [loadingContacts, setLoadingContacts] = useState(false);
  const [clientContactId, setClientContactId] = useState('');
  const [zip, setZip] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<{ created?: number; exists?: boolean } | null>(null);
  const [contactQuery, setContactQuery] = useState('');
  const [dropdownOpen, setDropdownOpen] = useState(false);

  useEffect(() => {
    let mounted = true;
    async function load() {
      try {
        setLoadingContacts(true);
        const res = await fetch('/api/contacts', { method: 'GET' });
        const json = await res.json();
        if (!res.ok) throw new Error(json?.error || 'Failed to load contacts');
        if (mounted) setContacts(json.contacts || []);
      } catch (e: any) {
        if (mounted) setError(e?.message || 'Failed to load contacts');
      } finally {
        if (mounted) setLoadingContacts(false);
      }
    }
    load();
    return () => { mounted = false; };
  }, []);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError(null);
    setResult(null);
    if (!clientContactId) {
      setError('Please select a Contact.');
      return;
    }
    if (!zip) {
      setError('Please enter a ZIP.');
      return;
    }
    try {
      const res = await fetch('/api/pulled-zips', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ client_contact_id: clientContactId, zip })
      });
      const json = await res.json();
      if (!res.ok) {
        setError(json?.error || 'Failed to add ZIP');
      } else {
        setResult(json);
      }
    } catch (e: any) {
      setError(e?.message || 'Unexpected error');
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-zinc-50 font-sans dark:bg-black">
      <main className="flex w-full max-w-3xl flex-col gap-8 rounded-lg bg-white p-8 shadow-sm dark:bg-zinc-900">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold text-zinc-900 dark:text-zinc-50">Add to Pulled Zips</h1>
          <Link href="/" className="text-sm text-zinc-600 hover:underline dark:text-zinc-300">← Back to Upload</Link>
        </div>
        <form onSubmit={onSubmit} className="flex flex-col gap-4">
          <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <label className="flex flex-col gap-2 relative">
              <span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">Contact</span>
              <input
                type="text"
                placeholder={loadingContacts ? 'Loading…' : 'Search contacts'}
                value={contactQuery}
                onChange={(e) => {
                  setContactQuery(e.target.value);
                  setDropdownOpen(true);
                }}
                onFocus={() => setDropdownOpen(true)}
                className="rounded-md border border-zinc-300 bg-white px-3 py-2 text-zinc-900 outline-none focus:ring-2 focus:ring-zinc-400 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50"
              />
              {dropdownOpen && (
                <div
                  className="absolute bottom-full left-0 right-0 mb-2 max-h-60 overflow-auto rounded-md border border-zinc-300 bg-white shadow-lg dark:border-zinc-700 dark:bg-zinc-800 z-10"
                  onMouseLeave={() => setDropdownOpen(false)}
                >
                  {(contacts || [])
                    .filter(c => c.label.toLowerCase().includes(contactQuery.toLowerCase()))
                    .slice(0, 200)
                    .map(c => (
                      <button
                        type="button"
                        key={c.id}
                        onClick={() => {
                          setClientContactId(c.id);
                          setContactQuery(c.label);
                          setDropdownOpen(false);
                        }}
                        className={`block w-full cursor-pointer px-3 py-2 text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 ${clientContactId === c.id ? 'bg-zinc-100 dark:bg-zinc-700' : ''}`}
                      >
                        {c.label}
                      </button>
                    ))}
                  {(contacts && (contacts.filter(c => c.label.toLowerCase().includes(contactQuery.toLowerCase())).length === 0)) && (
                    <div className="px-3 py-2 text-sm text-zinc-500 dark:text-zinc-300">No results</div>
                  )}
                </div>
              )}
              {clientContactId && (
                <div className="text-xs text-zinc-500 dark:text-zinc-400">Selected ID: {clientContactId}</div>
              )}
            </label>
            <div className="flex flex-col gap-2">
              <span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">Location</span>
              <div className="rounded-md border border-zinc-300 bg-zinc-50 px-3 py-2 text-zinc-900 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50">
                Jayden
              </div>
            </div>
          </div>
          <label className="flex flex-col gap-2">
            <span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">ZIP</span>
            <input
              type="text"
              placeholder="Enter any text"
              value={zip}
              onChange={(e) => setZip(e.target.value)}
              className="rounded-md border border-zinc-300 bg-white px-3 py-2 text-zinc-900 outline-none focus:ring-2 focus:ring-zinc-400 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-50"
            />
          </label>
          <button
            type="submit"
            className="inline-flex items-center justify-center rounded-md bg-black px-4 py-2 text-white hover:bg-zinc-800 dark:bg-zinc-100 dark:text-black dark:hover:bg-white"
          >
            Add ZIP
          </button>
        </form>
        {error && (
          <div className="rounded-md border border-red-300 bg-red-50 p-4 text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-100">
            {error}
          </div>
        )}
        {result && (
          <div className="rounded-md border border-zinc-200 bg-zinc-50 p-4 text-sm text-zinc-800 dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100">
            {result.exists ? 'ZIP already exists for this contact and location.' : 'ZIP added.'}
          </div>
        )}
      </main>
    </div>
  );
}



